<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Property Data Benchmarking & Validation</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" 
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>

    <style>
        
        /* ------------------------------------------- */
        /* --- M3 Color Palette (Custom/Inspired) --- */
        /* ------------------------------------------- */
        :root {
            /* Primary Colors */
            --color-primary: #1E4D9C; /* Deep Blue */
            --color-on-primary: #FFFFFF;
            --color-primary-container: #DCE1FF;
            --color-on-primary-container: #001A5E;

            /* Surface/Background */
            --color-surface: #F9F9FF;
            --color-on-surface: #1B1B21;
            --color-surface-container-high: #E3E2EA;
            --color-surface-container-low: #F3F3FA;
            
            /* Outline/Stroke */
            --color-outline: #777680;
            --color-error: #BA1A1A;

            /* Spacing */
            --m3-spacing-1: 4px;
            --m3-spacing-2: 8px;
            --m3-spacing-3: 12px;
            --m3-spacing-4: 16px;
            
            /* Typography */
            font-family: 'Roboto', sans-serif;
        }


        /* ------------------------- */
        /* --- Global & Layout --- */
        /* ------------------------- */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
            background-color: var(--color-surface);
            color: var(--color-on-surface);
        }

        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #map-container {
            flex-grow: 1; 
            min-height: 50%;
            position: relative;
            z-index: 1;
        }
        
        /* Message/Status Box for Alerts */
        #status-message {
            position: absolute;
            top: 72px; 
            left: 50%;
            transform: translateX(-50%);
            padding: var(--m3-spacing-2) var(--m3-spacing-4);
            background-color: var(--color-primary);
            color: var(--color-on-primary);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            max-width: 90vw;
            text-align: center;
        }
        
        #status-message.visible {
            opacity: 1;
            visibility: visible;
        }

        #status-message.error {
             background-color: var(--color-error);
        }


        /* -------------------------- */
        /* --- M3 Components (UI) --- */
        /* -------------------------- */
        .search-bar {
            position: absolute;
            top: var(--m3-spacing-3);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(300px, 80vw, 600px);
            background-color: var(--color-surface);
            border: 1px solid var(--color-outline);
            border-radius: 28px; 
            padding: var(--m3-spacing-2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: var(--m3-spacing-2);
            z-index: 1000; 
        }
        
        .search-input {
            flex-grow: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 1rem;
            padding: 0 var(--m3-spacing-2);
        }

        .icon-button {
            color: var(--color-on-surface);
            cursor: pointer;
            padding: var(--m3-spacing-2);
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .icon-button:hover {
            background-color: rgba(0, 0, 0, 0.04);
        }

        .filter-chip {
            display: flex;
            align-items: center;
            padding: var(--m3-spacing-1) var(--m3-spacing-3);
            border-radius: 8px;
            background-color: var(--color-primary-container);
            color: var(--color-on-primary-container);
            font-size: 0.875rem;
            cursor: pointer;
            border: 1px solid transparent;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }
        
        .filter-chip.selected {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        .filter-chip:hover:not(.selected) {
            background-color: #C1C6E6; 
        }
        
        /* Floating guidance tooltip */
        #search-guidance {
          position: absolute;
          top: 100%; /* vertically aligned with button */
          left: 50%;
          /* right: -160px; /* offset to appear beside search button */
          transform: translateY(-50%);
          margin-top: 4px;
          background-color: var(--color-primary);
          color: var(--color-on-primary);
          padding: 8px 12px;
          border-radius: 8px;
          box-shadow: 0 2px 6px rgba(0,0,0,0.2);
          font-size: 0.875rem;
          white-space: nowrap;
          opacity: 0;
          visibility: hidden;
          transition: opacity 0.3s ease;
          z-index: 2000;
        }

        /* Visible state */
        #search-guidance.visible {
          opacity: 1;
          visibility: visible;
        }

        /* Pulse animation for search button */
        @keyframes pulse {
          0% { transform: scale(1); }
          50% { transform: scale(1.15); background-color: #153C7D; color: #fff; }
          100% { transform: scale(1); }
        }

        .pulse {
          animation: pulse 0.8s ease-in-out;
        }


        /* ----------------------------------------------- */
        /* --- Bottom Sheet Panel (Data Presentation) --- */
        /* ----------------------------------------------- */
        #data-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 48px; 
            background-color: var(--color-surface-container-high);
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            transition: height 0.3s ease-in-out;
            z-index: 2; 
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #data-panel.expanded {
            height: 60vh; 
            max-height: 80vh; 
        }

        .panel-handle {
            height: 48px;
            padding: 0 var(--m3-spacing-4);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            background-color: var(--color-primary); 
            color: var(--color-on-primary);
        }

        .handle-icon {
            font-size: 1.25rem;
            cursor: pointer;
            padding: 4px;
        }

        .panel-content {
            padding: var(--m3-spacing-3);
            overflow-y: auto;
            flex-grow: 1;
            visibility: hidden; 
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #data-panel.expanded .panel-content {
            visibility: visible;
            opacity: 1;
        }


        /* --------------------------------- */
        /* --- Table Alignment Overrides --- */
        /* --------------------------------- */
        #data-table th {
            text-align: left;
            padding: 8px;
            border-bottom: 2px solid var(--color-primary);
            transition: none;
        }

        #data-table td {
            text-align: left;
            padding: 8px; 
            border-bottom: 1px solid var(--color-surface-container-high);
        }

        /* Right align numerical columns */
        #data-table th:nth-child(1), #data-table td:nth-child(1), /* Seq.Num */
        #data-table th:nth-child(2), #data-table td:nth-child(2), /* Bldg Num */
        #data-table th:nth-child(4), #data-table td:nth-child(4), /* Area */
        #data-table th:nth-child(5), #data-table td:nth-child(5), /* Perimeter */
        #data-table th:nth-child(6), #data-table td:nth-child(6), /* Height */
        #data-table th:nth-child(7), #data-table td:nth-child(7), /* Floor Levels */
        #data-table th:nth-child(8), #data-table td:nth-child(8) { /* OSM ID */
            text-align: right;
        }

        /* Name column left-aligned */
        #data-table th:nth-child(3), #data-table td:nth-child(3) {
            text-align: left;
        }
        
        
        /* --- Custom Marker Style for Seq.Num --- */
        .seq-marker {
            background-color: var(--color-primary); 
            color: var(--color-on-primary);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            line-height: 24px; /* Vertically center the text */
            text-align: center;
            font-weight: 500;
            font-size: 0.75rem;
            border: 2px solid var(--color-on-primary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            /* Important for Leaflet DivIcon: ensures the center is the anchor point */
            margin-left: -12px;
            margin-top: -12px;
        }
        
        .label-marker {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
        }

        .editable-cell {
            cursor: text;
            transition: background-color 0.2s;
        }

        .editable-cell:hover {
            background-color: #FFF4CC !important;
        }

        .editable-cell:focus {
            outline: 2px solid var(--color-primary);
            outline-offset: -2px;
            background-color: #FFFFFF !important;
        }


        /* --------------------------- */
        /* --- Sidebar (Left Panel) --- */
        /* --------------------------- */
        #left-sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100%;
            width: 0; 
            background-color: var(--color-surface);
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
            z-index: 10;
            transition: width 0.3s ease-in-out;
            overflow-x: hidden;
            padding-top: 56px; 
        }
        
        #left-sidebar.expanded {
            width: 250px;
            padding: var(--m3-spacing-4);
        }

        .sidebar-tool-button {
            display: block;
            width: 100%;
            padding: var(--m3-spacing-3);
            margin-bottom: var(--m3-spacing-2);
            text-align: left;
            border: none;
            border-radius: 8px;
            background-color: var(--color-surface-container-low);
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 1rem;
            color: var(--color-on-surface);
        }

        .sidebar-tool-button:hover {
            background-color: var(--color-surface-container-high);
        }
        
        
        /* ----------------------------------------- */
        /* --- Modal Overlay for GeoJSON Upload --- */
        /* ----------------------------------------- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            z-index: 2000;
            display: none; 
            justify-content: center;
            align-items: center;
        }

        #upload-modal {
            background-color: var(--color-surface);
            padding: var(--m3-spacing-4);
            border-radius: 28px;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
            width: clamp(300px, 80vw, 400px);
            display: flex;
            flex-direction: column;
            gap: var(--m3-spacing-3);
        }
        
        .modal-button {
            padding: var(--m3-spacing-2) var(--m3-spacing-4);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .modal-button.primary {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }

        .modal-button.secondary {
            background-color: var(--color-surface-container-high);
            color: var(--color-on-surface);
        }
        
        .modal-button.primary:hover { background-color: #153C7D; }
        .modal-button.secondary:hover { background-color: #CACACA; }

        /* driver.js tour styles */
        /* Help Button (positioned top-left, next to Leaflet zoom controls) */
        #help-button {
            position: fixed;
            top: 20px; /* Right of search bar */
            right: 20%;
            width: 40px;
            height: 40px;
            border-radius: 4px; /* Match Leaflet button style */
            background-color: var(--color-primary);
            color: var(--color-on-primary);
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
            z-index: 500; /* Below modals but above map controls */
        }

        #help-button:hover {
            background-color: #153C7D;
        }

        #help-button:active {
            transform: scale(0.95);
        }

                /* --- Driver.js Custom Styling --- */
        .driver-popover {
            background-color: var(--color-surface) !important;
            color: var(--color-on-surface) !important;
            border-radius: 12px !important;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25) !important;
            border: 1px solid var(--color-surface-container-high) !important;
            font-family: 'Roboto', sans-serif !important;
        }

        .driver-popover-title {
            font-size: 1.1rem !important;
            font-weight: 500 !important;
        }

        .driver-popover-description {
            font-size: 0.95rem !important;
            line-height: 1.5 !important;
        }

        .driver-active-element {
            z-index: 10001 !important;
        }

        .driver-overlay {
            background-color: rgba(0, 0, 0, 0.55) !important;
            z-index: 10000 !important;
        }

        /* ----------------------------- */
        /* --- Responsive adjustments --- */
        /* ----------------------------- */
        @media (max-width: 600px) {
            .search-bar {
                width: 90vw;
            }

            #data-panel.expanded {
                 height: 80vh;
            }
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="map-container"></div>
        
        <div id="status-message"></div>

        <div class="search-bar">
            <i class="fa-solid fa-bars icon-button" id="sidebar-toggle" title="Toggle Navigation"></i>

            <div id="filter-chips" style="display: flex; gap: var(--m3-spacing-1);">
                <span class="filter-chip selected" id="country-chip" data-key="country" data-value="Canada">Canada</span>
                <span class="filter-chip selected" id="region-chip" data-key="region" data-value="ON">ON</span>
            </div>

            <input type="text" placeholder="Search Address or Property Name..." class="search-input" id="address-search-input">

            <i class="fa-solid fa-plus icon-button" id="options-toggle" title="Load Data Options"></i>
            
            <i class="fa-solid fa-magnifying-glass icon-button" id="execute-search" title="Execute Search"></i>
        </div>
        
        <div class="action-prompt" id="action-prompt">
          Click search to load buildings
        </div>

        <div id="left-sidebar">
            <h3 style="margin-top: 0;">Map Tools & Area Definition</h3>
            <p style="font-size: 0.875rem; color: var(--color-outline);">Define your search area manually:</p>
            <button class="sidebar-tool-button" id="draw-bbox-tool">
                <i class="fa-solid fa-square-pen"></i> Draw Area (Box or Polygon)
            </button>
            <button class="sidebar-tool-button" id="clear-map-tool">
                <i class="fa-solid fa-trash-can"></i> Clear Map Boundary
            </button>
            <hr style="border: 0; border-top: 1px solid var(--color-surface-container-high); margin: var(--m3-spacing-4) 0;">
            <p style="font-size: 0.875rem; color: var(--color-outline);">Legend, Layers, and other settings will be here.</p>
        </div>

        <div id="data-panel">
            <div class="panel-handle" id="panel-handle">
                <span id="panel-title">Property Data Results</span>
                <div style="display: flex; gap: 16px; align-items: center;">
                    <span id="unit-toggle" class="filter-chip" style="padding: 4px 8px;" title="Click to switch between Metric and Imperial units">Metric</span>
                    <span id="label-toggle" class="filter-chip" style="padding: 4px 8px;" title="Toggle building labels on map">Labels: OFF</span>
                    <i class="fa-solid fa-download handle-icon" id="export-csv" title="Export to CSV"></i>
                    <i class="fa-solid fa-map-location-dot handle-icon" id="export-geojson" title="Export to GeoJSON"></i>
                    <i class="fa-solid fa-chevron-up handle-icon" id="panel-toggle" title="Toggle Panel"></i>
                </div>
            </div>
            
            <div class="panel-content">
                <p id="property-name-address">Results: 0 buildings | Total Area: 0 sqm</p>
                <table id="data-table" style="width: 100%; border-collapse: collapse; margin-top: 8px;">
                      <thead>
                          <tr>
                              <th style="cursor: pointer;">Seq.Num</th>
                              <th style="cursor: pointer;">Bldg Num</th>
                              <th style="cursor: pointer;">Name</th>
                              <th style="cursor: pointer;">Area (sqm)</th>
                              <th style="cursor: pointer;">Perimeter (m)</th>
                              <th style="cursor: pointer;">Height (m)</th>
                              <th style="cursor: pointer;">Floor Levels</th>
                              <th style="cursor: pointer;">YrBlt</th>
                              <th style="cursor: pointer;">OSM ID</th>
                          </tr>
                      </thead>
                    <tbody>
                        <tr><td colspan="7" style="text-align: center; padding: 16px; border-bottom: none;">Run a query to load data...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <div id="modal-overlay">
            <div id="upload-modal">
                <h3 style="margin: 0; color: var(--color-primary);">Load Data Options</h3>
                <p style="margin: 0;">Define the boundary using an external file.</p>
                
                <label for="geojson-file" style="font-weight: 500;">Select GeoJSON or CSV File:</label>
                <input type="file" id="geojson-file" accept=".geojson, .json, .csv" style="padding: var(--m3-spacing-2); border: 1px solid var(--color-outline); border-radius: 8px;">
                
                <div style="display: flex; justify-content: flex-end; gap: var(--m3-spacing-3); margin-top: var(--m3-spacing-3);">
                    <button class="modal-button secondary" id="modal-cancel">Cancel</button>
                    <button class="modal-button primary" id="modal-upload-process">Load Boundary</button>
                </div>
            </div>
        </div>
    </div>

        <!-- Help Button for Product Tour (positioned top-left near zoom controls) -->
    <button id="help-button" title="Start Interactive Tour (?) - Learn how to use the app">
        <i class="fa-solid fa-question"></i>
    </button>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js" 
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" 
        integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ==" 
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.3.1/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.3.1/dist/driver.css"/>

    <script>
        
        // --- Global Variables & Constants ---
        
        const mapElement = document.getElementById('map-container');
        const statusMessage = document.getElementById('status-message');
        const dataPanel = document.getElementById('data-panel');
        const panelToggle = document.getElementById('panel-toggle');
        const sidebarToggle = document.getElementById('sidebar-toggle');
        const leftSidebar = document.getElementById('left-sidebar');
        const countryChip = document.getElementById('country-chip');
        const regionChip = document.getElementById('region-chip');
        const addressInput = document.getElementById('address-search-input');
        const optionsToggle = document.getElementById('options-toggle');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalCancel = document.getElementById('modal-cancel');
        const uploadProcessBtn = document.getElementById('modal-upload-process');
        const geojsonFileInput = document.getElementById('geojson-file');
        const drawBboxTool = document.getElementById('draw-bbox-tool');
        const clearMapTool = document.getElementById('clear-map-tool');
        const unitToggle = document.getElementById('unit-toggle');
        const exportCsvBtn = document.getElementById('export-csv');
        const exportGeoJsonBtn = document.getElementById('export-geojson');
        const labelToggle = document.getElementById('label-toggle');
        // --- Guidance Feature Setup ---
        const executeSearchBtn = document.getElementById('execute-search');
        const actionPrompt = document.getElementById('action-prompt');
        
        let labelModeEnabled = false;

        // Store current map state and layers
        let currentBoundaryLayer = null;
        let searchAreaDefined = 'None'; 
        
        const BOUNDARY_TOLERANCE_RATIO = 0.40; 
        
        const REGIONS = {
            'Canada': ['ON', 'QC', 'BC', 'AB', 'MB', 'SK', 'NS', 'NB', 'PE', 'NL'],
            'United States': ['CA', 'TX', 'NY', 'FL', 'IL', 'PA', 'OH', 'MI', 'GA', 'NC'] 
        };
        
        let currentSearchState = {
            country: 'Canada',
            region: 'ON'
        };

        // --- Unit State and Conversions ---
        
        let currentUnitSystem = 'metric';
        const SQM_TO_SQFT = 10.7639;
        const M_TO_FT = 3.28084;
        
        /**
         * Formats a raw metric measurement into the current unit system.
         * @param {number|null|undefined} value - The metric value (sqm or m).
         * @param {'area'|'length'|'height'} type - The type of measurement.
         * @returns {{value: string, unit: string}} An object containing the formatted value and unit.
         */
        function formatMeasurement(value, type) {
            if (value === null || value === undefined) return { value: '-', unit: '' };

            if (currentUnitSystem === 'metric') {
                if (type === 'area') return { value: value.toLocaleString(undefined, { maximumFractionDigits: 0 }), unit: 'sqm' };
                if (type === 'length') return { value: value.toLocaleString(undefined, { maximumFractionDigits: 1 }), unit: 'm' };
                if (type === 'height') return { value: value.toLocaleString(undefined, { maximumFractionDigits: 1 }), unit: 'm' };
            } else { // imperial
                if (type === 'area') return { value: (value * SQM_TO_SQFT).toLocaleString(undefined, { maximumFractionDigits: 0 }), unit: 'sqft' };
                if (type === 'length') return { value: (value * M_TO_FT).toLocaleString(undefined, { maximumFractionDigits: 1 }), unit: 'ft' };
                if (type === 'height') return { value: (value * M_TO_FT).toLocaleString(undefined, { maximumFractionDigits: 1 }), unit: 'ft' };
            }
            return { value: value.toLocaleString(), unit: '' };
        }


        // --- Map Initialization ---

        const map = L.map(mapElement, {
            zoomControl: false 
        }).setView([43.6532, -79.3832], 12); 

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        L.control.zoom({
            position: 'topleft'
        }).addTo(map);

        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        const drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnItems
            },
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true,
                    shapeOptions: {
                        color: '#1E4D9C', fillOpacity: 0.1, weight: 3
                    }
                }, // Added Polygon tool
                marker: false, circle: false, polyline: false, circlemarker: false,
                rectangle: {
                    shapeOptions: {
                        color: '#1E4D9C', fillOpacity: 0.1, weight: 3
                    }
                }
            }
        });
        
        // --- Utility Functions ---

        /**
         * Displays a temporary status or alert message to the user.
         * @param {string} message - The message content.
         * @param {string} [type='success'] - The type of message ('success' or 'error').
         * @param {number} [duration=3000] - Duration in milliseconds the message is displayed.
         */
        function showStatus(message, type = 'success', duration = 3000) {
            statusMessage.textContent = message;
            statusMessage.className = 'visible';
            if (type === 'error') {
                statusMessage.classList.add('error');
            } else {
                statusMessage.classList.remove('error');
            }

            setTimeout(() => {
                statusMessage.classList.remove('visible');
            }, duration);
        }
        
        /**
         * Clears all boundaries, footprints, markers, results, and resets the UI state.
         * Handles both GeoJSON boundaries and CSV-loaded building footprints.
         */
        function clearBoundary() {
            // --- Clear GeoJSON boundary layer ---
            if (currentBoundaryLayer) {
                map.removeLayer(currentBoundaryLayer);
                currentBoundaryLayer = null;
            }

            // --- Clear CSV footprints / building layer group ---
            if (window.buildingsLayerGroup) {
                map.removeLayer(window.buildingsLayerGroup);
                window.buildingsLayerGroup = null;
            }

            // --- Reset state flags ---
            searchAreaDefined = 'None';
            window.currentBuildingsData = [];

            // --- Reset UI elements ---
            showStatus('All boundaries and building footprints cleared.', 'success', 2000);
            hideActionPrompt();

            // Reset input fields
            if (typeof lastGeocodedAddress !== 'undefined') {
                lastGeocodedAddress = '';
            }
            addressInput.value = '';

            // Reset data table
            populateDataTable([]);

            // Clear drawn shapes
            drawnItems.clearLayers();

            // Re-enable chips (country/region selection)
            countryChip.style.pointerEvents = 'auto';
            regionChip.style.pointerEvents = 'auto';
        }

        /**
         * Adds a GeoJSON feature (Polygon/MultiPolygon) to the map as the search boundary.
         * @param {object} geojsonData - The parsed GeoJSON object.
         */
        function addGeoJsonBoundaryToMap(geojsonData) {
            clearBoundary(); 
            
            currentBoundaryLayer = L.geoJSON(geojsonData, {
                style: function (feature) {
                    return {
                        color: '#1E4D9C', weight: 3, opacity: 1, fillColor: '#1E4D9C', fillOpacity: 0.1
                    };
                }
            }).addTo(map);
            
            map.fitBounds(currentBoundaryLayer.getBounds());
            searchAreaDefined = 'GeoJSON';
            showStatus('GeoJSON boundary loaded successfully. Retrieving data...', 'success');
            
            countryChip.style.pointerEvents = 'none';
            regionChip.style.pointerEvents = 'none';

            executeDataExtraction();
        }

        /**
         * Utility to convert Leaflet coordinates (lat/lng) to Overpass poly format (lat lon lat lon...).
         * @param {L.Polygon|L.Rectangle} layer - The Leaflet Polygon or Rectangle layer.
         * @returns {string} The coordinates string in Overpass poly format.
         */
        function extractPolygonCoordinates(layer) {
            // Get coordinates from the Leaflet layer
            const latLngs = layer.getLatLngs()[0]; // For simple polygon/rectangle
            
            // Format into the "lat lon lat lon..." string required by Overpass's poly
            const polyCoords = latLngs.map(latlng => `${latlng.lat.toFixed(6)} ${latlng.lng.toFixed(6)}`).join(' ');
            
            return polyCoords;
        }
        
        /**
         * Shows visual feedback prompting user to take the next action.
         * @param {string} message - The message content.
         * @param {number} [duration=5000] - Duration in milliseconds the prompt is displayed.
         */
        function showActionPrompt(message, duration = 5000) {
            actionPrompt.textContent = message;
            actionPrompt.classList.add('visible');
            executeSearchBtn.classList.add('pulse');
            
            setTimeout(() => {
                actionPrompt.classList.remove('visible');
                executeSearchBtn.classList.remove('pulse');
            }, duration);
        }

        /**
         * Hides the action prompt immediately.
         */
        function hideActionPrompt() {
            actionPrompt.classList.remove('visible');
            executeSearchBtn.classList.remove('pulse');
        }

        // Create guidance element dynamically
        let guidanceEl = document.createElement('div');
        guidanceEl.id = 'search-guidance';
        guidanceEl.textContent = 'Click search again to load building data';
        executeSearchBtn.parentElement.appendChild(guidanceEl);

        let guidanceTimeout;

        /**
         * Show floating guidance near search button
         */
        function showSearchGuidance() {
          clearTimeout(guidanceTimeout);
          guidanceEl.classList.add('visible');
          executeSearchBtn.classList.add('pulse');

          // Auto-dismiss after 5 seconds
          guidanceTimeout = setTimeout(() => {
            hideSearchGuidance();
          }, 5000);
        }

        /**
         * Hide guidance immediately
         */
        function hideSearchGuidance() {
          guidanceEl.classList.remove('visible');
          executeSearchBtn.classList.remove('pulse');
        }

        /**
         * Integration point: after geocoding success
         * Call this function once the map pans to the searched location.
         */
        function handleGeocodeSuccess(marker) {
          map.once('moveend', () => {
            showSearchGuidance();
          });
        }

        // --- Event Bindings ---

        // Hide guidance when user clicks search again
        executeSearchBtn.addEventListener('click', () => {
          if (guidanceEl.classList.contains('visible')) {
            hideSearchGuidance();
            // Proceed to building data extraction logic...
            executeDataExtraction();
          } else {
            // First search action (geocoding)
            handleGeocodeSuccess();
          }
        });



        // --- UI/UX Event Handlers ---

        /**
         * Toggles the visibility and size of the data results panel.
         */
        function toggleDataPanel() {
            dataPanel.classList.toggle('expanded');
            const isExpanded = dataPanel.classList.contains('expanded');
            const icon = isExpanded ? 'fa-chevron-down' : 'fa-chevron-up'; 
            panelToggle.className = `fa-solid ${icon} handle-icon`;
            panelToggle.title = isExpanded ? 'Collapse Panel' : 'Expand Panel';
        }


        /**
         * Toggles the visibility and size of the left sidebar.
         */
        function toggleSidebar() {
            leftSidebar.classList.toggle('expanded');
            const isExpanded = leftSidebar.classList.contains('expanded');
            sidebarToggle.classList.toggle('fa-bars');
            sidebarToggle.classList.toggle('fa-arrow-left');
            sidebarToggle.title = isExpanded ? 'Collapse Sidebar' : 'Expand Sidebar';
            console.log('ðŸ”€ Sidebar toggled:', isExpanded ? 'expanded' : 'collapsed');
            // Invalidate size ensures map tiles re-render correctly after container size changes
            setTimeout(() => map.invalidateSize(), 300);
        }

        document.getElementById('panel-handle').addEventListener('click', (e) => {
            // Only toggle if the click target is NOT the export or unit toggle button
            if (e.target.id !== 'export-csv' && e.target.id !== 'unit-toggle' && e.target.id !== 'export-geojson') {
                toggleDataPanel();
            }
        });

        sidebarToggle.addEventListener('click', toggleSidebar);

        clearMapTool.addEventListener('click', clearBoundary);
        
        /**
         * Event listener for unit toggle button. Switches between metric and imperial units.
         */
        unitToggle.addEventListener('click', () => {
            currentUnitSystem = currentUnitSystem === 'metric' ? 'imperial' : 'metric';
            unitToggle.textContent = currentUnitSystem === 'metric' ? 'Metric' : 'Imperial';
            showStatus(`Unit system switched to ${currentUnitSystem.toUpperCase()}.`, 'success', 2000);

            // Re-render the table and map popups if data exists
            if (window.currentBuildingsData && window.currentBuildingsData.length > 0) {
                populateDataTable(window.currentBuildingsData);
                displayBuildingsOnMap(window.currentBuildingsData);
            }
        });

        /**
         * Event listener for label toggle button. Switches map labels on/off.
         */
        labelToggle.addEventListener('click', () => {
            labelModeEnabled = !labelModeEnabled;
            labelToggle.textContent = labelModeEnabled ? 'Labels: ON' : 'Labels: OFF';
            labelToggle.classList.toggle('selected', labelModeEnabled);
            
            showStatus(`Label mode ${labelModeEnabled ? 'enabled' : 'disabled'}.`, 'success', 2000);

            // Re-render map markers if data exists
            if (window.currentBuildingsData && window.currentBuildingsData.length > 0) {
                displayBuildingsOnMap(window.currentBuildingsData);
            }
        });


        // --- 2.2 Filter Chips Logic ---
        
        /**
         * Updates the region chip and sets the map view based on the selected country.
         * @param {string} country - The country name ('Canada' or 'United States').
         */
        function updateRegionChip(country) {
            const defaultRegion = REGIONS[country][0]; 
            currentSearchState.region = defaultRegion;
            regionChip.textContent = defaultRegion;
            regionChip.dataset.value = defaultRegion;
            regionChip.title = `Current region filter: ${defaultRegion}`;
            
            if (country === 'Canada') {
                 map.setView([43.6532, -79.3832], 12);
            } else {
                 map.setView([34.0522, -118.2437], 12);
            }
        }
        
        countryChip.addEventListener('click', () => {
            if (searchAreaDefined !== 'None') {
                 showStatus('Clear map boundary before changing filters.', 'error');
                 return;
            }
            
            const currentCountry = currentSearchState.country;
            const nextCountry = currentCountry === 'Canada' ? 'United States' : 'Canada';
            
            currentSearchState.country = nextCountry;
            countryChip.textContent = nextCountry;
            countryChip.dataset.value = nextCountry;
            countryChip.title = `Current country filter: ${nextCountry}`;
            
            updateRegionChip(nextCountry);
            showStatus(`Country set to ${nextCountry}. Region reset to ${currentSearchState.region}.`, 'success', 2000);
        });

        regionChip.addEventListener('click', () => {
            if (searchAreaDefined !== 'None') {
                 showStatus('Clear map boundary before changing filters.', 'error');
                 return;
            }
            
            const availableRegions = REGIONS[currentSearchState.country];
            const currentIndex = availableRegions.indexOf(currentSearchState.region);
            
            // Calculate next index, looping back to 0
            const nextIndex = (currentIndex + 1) % availableRegions.length;
            const nextRegion = availableRegions[nextIndex];
            
            // Update state and chip
            currentSearchState.region = nextRegion;
            regionChip.textContent = nextRegion;
            regionChip.dataset.value = nextRegion;
            regionChip.title = `Current region filter: ${nextRegion}`;
            
            // Note: Map view is not updated here as it's country-level, not region-level defined.
            showStatus(`Region successfully changed to ${nextRegion} for ${currentSearchState.country}.`, 'success', 2000);
        });


        // --- 2.3 GeoJSON Upload Modal Logic ---

        optionsToggle.addEventListener('click', () => {
            modalOverlay.style.display = 'flex';
        });

        modalCancel.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target.id === 'modal-overlay') {
                modalOverlay.style.display = 'none';
            }
        });
        
        uploadProcessBtn.addEventListener('click', () => {
            const file = geojsonFileInput.files[0];
            if (!file) {
                showStatus('Please select a GeoJSON or CSV file.', 'error');
                return;
            }

            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.csv')) {
                // Handle CSV Import
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        try {
                            processImportedCSV(results.data);
                            modalOverlay.style.display = 'none';
                            geojsonFileInput.value = '';
                        } catch (error) {
                            showStatus(`CSV import failed: ${error.message}`, 'error', 5000);
                            console.error('CSV import error:', error);
                        }
                    },
                    error: function(error) {
                        showStatus(`CSV parsing failed: ${error.message}`, 'error', 5000);
                    }
                });
                
            } else if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                // Handle GeoJSON Import (existing logic)
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const geojsonData = JSON.parse(e.target.result);
                        
                        if (!geojsonData.type || (geojsonData.type !== 'FeatureCollection' && geojsonData.type !== 'Feature' && geojsonData.type !== 'Polygon' && geojsonData.type !== 'MultiPolygon')) {
                            throw new Error("Invalid GeoJSON structure. Must be Feature, FeatureCollection, Polygon, or MultiPolygon.");
                        }
                        
                        addGeoJsonBoundaryToMap(geojsonData);
                        modalOverlay.style.display = 'none';
                        geojsonFileInput.value = '';
                        
                    } catch (error) {
                        showStatus(`Error processing GeoJSON: ${error.message}`, 'error', 5000);
                        console.error('GeoJSON parsing error:', error);
                    }
                };
                reader.onerror = () => {
                    showStatus('Failed to read file.', 'error');
                };
                reader.readAsText(file);
                
            } else {
                showStatus('Invalid file type. Please select a .csv, .geojson, or .json file.', 'error');
            }
        });

        /**
         * Processes imported CSV data, extracting building coordinates and metrics,
         * then displays them on the map and table.
         * @param {Array<Object>} csvData - Array of objects parsed from the CSV file.
         * @throws {Error} If the CSV data is empty or contains no valid records.
         */
        function processImportedCSV(csvData) {
            if (!csvData || csvData.length === 0) {
                throw new Error('CSV file is empty or invalid.');
            }
            
            showStatus('Processing imported CSV data...', 'success', 3000);
            
            // Clear existing data
            clearBoundary();
            
            const buildings = [];
            let minLat = Infinity, maxLat = -Infinity;
            let minLng = Infinity, maxLng = -Infinity;
            
            csvData.forEach((row, index) => {
                try {
                    // Parse footprint coordinates from JSON string
                    let coordinates;
                    try {
                        coordinates = JSON.parse(row['Footprint Coordinates']);
                        if (!Array.isArray(coordinates) || coordinates.length < 3) {
                            throw new Error('Invalid coordinate structure');
                        }
                    } catch (e) {
                        console.warn(`Skipping row ${index + 1}: Invalid footprint coordinates`, e);
                        return;
                    }
                    
                    // Update bounding box for map fitting
                    coordinates.forEach(coord => {
                        if (coord && coord.length >= 2) {
                            const lng = coord[0];
                            const lat = coord[1];
                            minLng = Math.min(minLng, lng);
                            maxLng = Math.max(maxLng, lng);
                            minLat = Math.min(minLat, lat);
                            maxLat = Math.max(maxLat, lat);
                        }
                    });
                    
                    // Parse tags from JSON string
                    let tags = {};
                    try {
                        tags = row['Tags'] ? JSON.parse(row['Tags']) : {};
                    } catch (e) {
                        console.warn(`Row ${index + 1}: Could not parse tags`);
                    }
                    
                    // Build the building object
                    // NOTE: Area/Perimeter/Height columns can be in metric OR imperial units
                    // depending on which unit system was active during CSV export.
                    // Check for both metric and imperial column names for flexibility.
                    
                    let area = parseFloat(row['Area (sqm)']) || parseFloat(row['Area (sqft)']) || 0;
                    let perimeter = parseFloat(row['Perimeter (m)']) || parseFloat(row['Perimeter (ft)']) || 0;
                    let height = row['Height (m)'] ? parseFloat(row['Height (m)']) : 
                                 row['Height (ft)'] ? parseFloat(row['Height (ft)']) : null;
                    
                    // Convert imperial to metric if necessary
                    const isImperial = (row['Area (sqft)'] !== undefined && row['Area (sqm)'] === undefined) ||
                                       (row['Perimeter (ft)'] !== undefined && row['Perimeter (m)'] === undefined) ||
                                       (row['Height (ft)'] !== undefined && row['Height (m)'] === undefined);
                    
                    if (isImperial) {
                        area = (area / SQM_TO_SQFT); // Convert sqft back to sqm
                        perimeter = (perimeter / M_TO_FT); // Convert ft back to m
                        if (height !== null) {
                            height = (height / M_TO_FT); // Convert ft back to m
                        }
                    }
                    
                    const building = {
                        seqNum: row['Seq.Num'] || index + 1,
                        bldgNum: row['Bldg Num'] || '',
                        name: row['Name'] || 'Unnamed',
                        area: area,
                        perimeter: perimeter,
                        height: height,
                        floorLevels: row['Floor Levels'] ? parseInt(row['Floor Levels']) : null,
                        yearBuilt: row['YrBlt'] || null,  // NEW PROPERTY
                        osmId: row['OSM ID'] || '',
                        osmType: 'way',
                        coordinates: coordinates,
                        tags: tags
                    };
                    
                    buildings.push(building);
                    
                } catch (error) {
                    console.error(`Error processing CSV row ${index + 1}:`, error);
                }
            });
            
            if (buildings.length === 0) {
                throw new Error('No valid building records found in CSV.');
            }
            
            // Store the imported data
            window.currentBuildingsData = buildings;
            
            // Display on map
            displayBuildingsOnMap(buildings);
            
            // Populate table
            populateDataTable(buildings);
            
            // Fit map to imported buildings
            if (minLat !== Infinity && maxLat !== -Infinity) {
                const bounds = L.latLngBounds(
                    [minLat, minLng],
                    [maxLat, maxLng]
                );
                map.fitBounds(bounds, { padding: [50, 50] });
            }
            
            // Update UI state
            searchAreaDefined = 'CSV_IMPORT';
            countryChip.style.pointerEvents = 'none';
            regionChip.style.pointerEvents = 'none';
            
            showStatus(`Successfully imported ${buildings.length} buildings from CSV!`, 'success', 4000);
            
            // Expand data panel if collapsed
            if (!dataPanel.classList.contains('expanded')) {
                toggleDataPanel();
            }
        }

        
        // --- 2.4 Address Search Logic (Nominatim Geocoding) ---

        const NOMINATIM_URL = 'https://nominatim.openstreetmap.org/search';

        /**
         * Uses Nominatim to geocode an address, sets a marker on the map,
         * and flies the map view to the result's bounding box.
         * @param {string} address - The address string to search for.
         * @returns {Promise<void>}
         */
        async function geocodeAddress(address) {
             if (!address.trim()) {
                showStatus('Please enter an address to search.', 'error');
                return;
            }
            
            showStatus(`Searching for: ${address}...`, 'success', 5000);

            const url = new URL(NOMINATIM_URL);
            url.searchParams.append('q', `${address}, ${currentSearchState.region}, ${currentSearchState.country}`);
            url.searchParams.append('format', 'json');
            url.searchParams.append('limit', 1);

            try {
                const response = await fetch(url.toString());
                if (!response.ok) {
                    throw new Error(`Nominatim API returned status: ${response.status}`);
                }
                const data = await response.json();

                if (data.length > 0) {
                    const result = data[0];
                    const lat = parseFloat(result.lat);
                    const lon = parseFloat(result.lon);
                    const boundingBox = result.boundingbox.map(parseFloat); 

                    map.flyToBounds([
                        [boundingBox[0], boundingBox[2]],
                        [boundingBox[1], boundingBox[3]]
                    ], { padding: [20, 20] });
                    
                    clearBoundary();
                    currentBoundaryLayer = L.marker([lat, lon]).addTo(map)
                        .bindPopup(`<b>${result.display_name}</b>`).openPopup();
                    searchAreaDefined = 'Chips';
                    lastGeocodedAddress = address; // Track the geocoded address

                    console.log('Geocoding successful. Marker added:', currentBoundaryLayer, 'searchAreaDefined:', searchAreaDefined);
                    showStatus(`Found: ${result.display_name}`, 'success', 4000);

                    // Show action prompt to guide user
                    handleGeocodeSuccess();
                    
                } else {
                    showStatus(`No results found for "${address}". Try being more specific.`, 'error');
                }
            } catch (error) {
                showStatus(`Geocoding failed: ${error.message}`, 'error', 5000);
                console.error('Geocoding error:', error);
            }
        }


        // --- 2.5 Bounding Box / Polygon Tool Logic ---

        let drawControlEnabled = false;
        
        drawBboxTool.addEventListener('click', () => {
            if (searchAreaDefined !== 'None' && searchAreaDefined !== 'BBOX' && searchAreaDefined !== 'DRAWN_POLYGON') {
                showStatus('Clear existing GeoJSON or Marker boundary first.', 'error');
                return;
            }
            
            if (!drawControlEnabled) {
                map.addControl(drawControl);
                drawControlEnabled = true;
                showStatus('Draw a rectangle or polygon on the map to define the search area.', 'success', 4000);
                drawBboxTool.innerHTML = '<i class="fa-solid fa-square-pen"></i> Disable Draw Tool';
                drawBboxTool.classList.add('selected');
                toggleSidebar();
            } else {
                map.removeControl(drawControl);
                drawControlEnabled = false;
                showStatus('Draw tool disabled.', 'success', 2000);
                drawBboxTool.innerHTML = '<i class="fa-solid fa-square-pen"></i> Draw Area (Box or Polygon)';
                drawBboxTool.classList.remove('selected');
            }
        });

        map.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            const type = e.layerType;
            
            // --- 1. Robust Cleanup of previous state to avoid conflicts ---
            // If an old boundary exists (Marker, GeoJSON, or old Drawn), remove it from the map.
            if (currentBoundaryLayer) {
                map.removeLayer(currentBoundaryLayer);
            }
            // Clear any previously editable layers from the draw group (ensures only the new layer remains).
            drawnItems.clearLayers(); 
            
            // Clear previous results/data state
            if (window.buildingsLayerGroup) {
                map.removeLayer(window.buildingsLayerGroup);
            }
            populateDataTable([]);
            window.currentBuildingsData = [];
            addressInput.value = ''; // Ensure address input is cleared when drawing new boundary
            
            // --- 2. Add the new layer and set state ---
            drawnItems.addLayer(layer);
            currentBoundaryLayer = layer;
            
            if (type === 'rectangle') {
                searchAreaDefined = 'BBOX';
            } else if (type === 'polygon') {
                searchAreaDefined = 'DRAWN_POLYGON';
            }
            
            const bounds = layer.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();
            
            console.log(`${searchAreaDefined} Defined. BBOX: [${sw.lat}, ${sw.lng}, ${ne.lat}, ${ne.lng}]`);
            showStatus(`${searchAreaDefined} area defined. Retrieving data...`, 'success', 4000);
            
            // --- 3. Disable the draw tool ---
            map.removeControl(drawControl);
            drawControlEnabled = false;
            drawBboxTool.innerHTML = '<i class="fa-solid fa-square-pen"></i> Draw Area (Box or Polygon)';
            drawBboxTool.classList.remove('selected');

            countryChip.style.pointerEvents = 'none';
            regionChip.style.pointerEvents = 'none';

            executeDataExtraction();
        });


        // --- PHASE 3: Data Retrieval and Analysis ---

        const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
        const MAX_RETRIES = 3;
        const INITIAL_BACKOFF = 2000; 

        /**
         * Constructs the Overpass QL query based on the currently defined search area.
         * @returns {string|null} The Overpass QL query string, or null if no boundary is defined.
         */
        function buildOverpassQuery() {
            let query = '[out:json][timeout:25];';
            let geometryFilter = '';
            let boundsQuery = '';

            if (currentBoundaryLayer) {
                if (searchAreaDefined === 'BBOX' || searchAreaDefined === 'Chips') {
                    let bounds;
                    if (searchAreaDefined === 'Chips') {
                        const latlng = currentBoundaryLayer.getLatLng();
                        const offset = 0.001;
                        bounds = L.latLngBounds([
                            [latlng.lat - offset, latlng.lng - offset],
                            [latlng.lat + offset, latlng.lng + offset]
                        ]);
                    } else {
                        bounds = currentBoundaryLayer.getBounds();
                    }
                    
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();

                    geometryFilter = `(${south},${west},${north},${east})`;
                    boundsQuery = geometryFilter; // Use bbox for initial query
                    
                } else if (searchAreaDefined === 'DRAWN_POLYGON') {
                    // Use the poly: filter for the Overpass query's primary geometry constraint
                    const polyCoords = extractPolygonCoordinates(currentBoundaryLayer);
                    geometryFilter = `(poly:"${polyCoords}")`;
                    
                    // Also calculate a bounding box for the initial query to limit the data retrieval
                    const bounds = currentBoundaryLayer.getBounds();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();
                    boundsQuery = `(${south},${west},${north},${east})`;
                    
                } else if (searchAreaDefined === 'GeoJSON') {
                    // For GeoJSON, we only use the BBOX of the GeoJSON layer for the initial query
                    // and rely on Turf.js for precise clipping (as geometry filter is complex)
                    const bounds = currentBoundaryLayer.getBounds();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();
                    boundsQuery = `(${south},${west},${north},${east})`;
                    geometryFilter = boundsQuery; // Use bounds as default query filter for generic geometry
                }
            } else {
                showStatus('No valid search area defined.', 'error');
                return null;
            }
            
            // Apply the bounding box (boundsQuery) to the initial set of elements to limit retrieval
            // And use the geometryFilter (bbox or poly) to filter the results more precisely later
            
            let elementsQuery = '';
            if (searchAreaDefined === 'DRAWN_POLYGON') {
                 // Use the poly: filter directly in the Overpass query
                 elementsQuery = `
                    node["building"]${geometryFilter};
                    way["building"]${geometryFilter};
                    relation["building"]${geometryFilter};
                 `;
            } else {
                 // Use the bounding box for GeoJSON/BBOX/Chips (as poly is not available or too simple)
                 elementsQuery = `
                    node["building"]${boundsQuery};
                    way["building"]${boundsQuery};
                    relation["building"]${boundsQuery};
                 `;
            }

            query += `(
                ${elementsQuery}
            );`;
            
            query += 'out body;>;out skel qt;';
            
            return query;
        }

        /**
         * Executes the Overpass QL query, with rate-limiting retry logic.
         * @param {string} query - The Overpass QL query string.
         * @param {number} [retryCount=0] - The current retry attempt number.
         * @returns {Promise<Object>} The JSON response data from Overpass.
         * @throws {Error} If API errors persist after max retries.
         */
        async function executeOverpassQuery(query, retryCount = 0) {
            try {
                const response = await fetch(OVERPASS_URL, {
                    method: 'POST',
                    body: `data=${encodeURIComponent(query)}`,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                });

                if (!response.ok) {
                    if (response.status === 429 || response.status === 504) {
                        throw new Error(`RETRY:${response.status}`);
                    }
                    throw new Error(`Overpass API error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                return data;

            } catch (error) {
                if (error.message.startsWith('RETRY:') && retryCount < MAX_RETRIES) {
                    const backoffTime = INITIAL_BACKOFF * Math.pow(2, retryCount);
                    showStatus(`Query rate limited. Retrying in ${backoffTime/1000}s... (Attempt ${retryCount + 1}/${MAX_RETRIES})`, 'success', backoffTime);
                    
                    await new Promise(resolve => setTimeout(resolve, backoffTime));
                    return executeOverpassQuery(query, retryCount + 1);
                }
                throw error;
            }
        }

        /**
         * Calculates the area of a polygon using Turf.js.
         * @param {Array<Array<number>>} coordinates - An array of [lon, lat] coordinate pairs.
         * @returns {number} The calculated area in square meters.
         */
        function calculateArea(coordinates) {
            try {
                const polygon = turf.polygon([coordinates]);
                const area = turf.area(polygon);
                return Math.round(area * 100) / 100;
            } catch (error) {
                console.warn('Area calculation failed:', error);
                return 0;
            }
        }

        /**
         * Calculates the perimeter of a polygon using Turf.js.
         * @param {Array<Array<number>>} coordinates - An array of [lon, lat] coordinate pairs.
         * @returns {number} The calculated perimeter in meters.
         */
        function calculatePerimeter(coordinates) {
            try {
                const lineString = turf.lineString(coordinates);
                const perimeter = turf.length(lineString, { units: 'meters' });
                return Math.round(perimeter * 100) / 100;
            } catch (error) {
                console.warn('Perimeter calculation failed:', error);
                return 0;
            }
        }
        
         /**
         * Extracts the year (YYYY format) from various OSM date formats (e.g., YYYY, YYYY-MM-DD).
         * @param {string} dateString - The date string from OSM tags.
         * @returns {string|null} - The year in YYYY format, or null if not parseable.
         */
        function extractYearFromDate(dateString) {
            if (!dateString || typeof dateString !== 'string') {
                return null;
            }
            
            // Remove whitespace
            dateString = dateString.trim();
            
            // Match YYYY at the start of the string (handles YYYY, YYYY-MM-DD, YYYY-MM, etc.)
            const yearMatch = dateString.match(/^(\d{4})/);
            if (yearMatch) {
                const year = parseInt(yearMatch[1]);
                // Validate reasonable year range (1000-2100)
                if (year >= 1000 && year <= 2100) {
                    return yearMatch[1];
                }
            }
            
            return null;
        }

        /**
         * Processes the raw OSM data (nodes and ways) by connecting nodes to ways,
         * calculating area/perimeter, and applying the boundary clipping filter.
         * @param {Object} overpassData - The raw JSON data returned from the Overpass API.
         * @returns {Array<Object>} An array of structured building objects.
         */
        function processOverpassData(overpassData) {
            const buildings = [];
            const nodeCache = {};
            
            // --- Pass 1: Cache Nodes (Fixes the critical bug) ---
            // We must cache ALL nodes before processing ANY ways.
            // Order: [lon, lat] is required for Turf.js compatibility.
            overpassData.elements.forEach(element => {
                if (element.type === 'node') {
                    nodeCache[element.id] = [element.lon, element.lat];
                }
            });
            
            // Setup clipping boundary (Same as original file)
            let clippingBoundary = null;
            if (currentBoundaryLayer && searchAreaDefined !== 'Chips') {
                clippingBoundary = currentBoundaryLayer.toGeoJSON();
                if (clippingBoundary.features && clippingBoundary.features.length > 0) {
                    clippingBoundary = clippingBoundary.features[0];
                }
            } else if (searchAreaDefined === 'Chips' && currentBoundaryLayer) {
                    const coords = currentBoundaryLayer.getLatLng();
                    const offset = 0.001; 
                    clippingBoundary = turf.bboxPolygon([coords.lng - offset, coords.lat - offset, coords.lng + offset, coords.lat + offset]);
            }
            
            const validPolygonTypes = ['Polygon', 'MultiPolygon'];
            if (!clippingBoundary || !validPolygonTypes.includes(clippingBoundary.geometry.type)) {
                if (searchAreaDefined !== 'Chips') {
                    console.warn(`Clipping boundary geometry type '${clippingBoundary ? clippingBoundary.geometry.type : 'None'}' is not a valid Polygon type. Skipping area-ratio filter.`);
                }
                clippingBoundary = null; 
            }

            let sequenceNumber = 1;

            // --- Pass 2: Process Ways ---
            overpassData.elements.forEach((element) => {
                if (element.type === 'way' && element.tags && element.tags.building) {
                    // Retrieve coordinates from the fully populated cache
                    const coordinates = element.nodes
                        .map(nodeId => nodeCache[nodeId])
                        .filter(coord => coord !== undefined);
                    
                    if (coordinates.length < 3) return;
                    
                    // Close the polygon ring if necessary
                    if (coordinates[0][0] !== coordinates[coordinates.length - 1][0] ||
                        coordinates[0][1] !== coordinates[coordinates.length - 1][1]) {
                        coordinates.push(coordinates[0]);
                    }
                    
                    // --- Original Logic: Boundary Clipping & Calculations ---
                    const buildingPolygon = turf.polygon([coordinates]);

                    if (clippingBoundary) {
                        const intersection = turf.intersect(buildingPolygon, clippingBoundary);

                        if (!intersection) {
                            console.log(`[FILTER EXCLUDED] ID:${element.id} (${element.tags.name || element.tags.building}): 0% inside boundary.`);
                            return;
                        }

                        const areaInside = turf.area(intersection);
                        const areaOriginal = turf.area(buildingPolygon);
                        
                        if (areaOriginal === 0) return; 

                        const ratio = areaInside / areaOriginal;
                        
                        if (ratio < BOUNDARY_TOLERANCE_RATIO) {
                            console.log(`[FILTER EXCLUDED] ID:${element.id}: Area Ratio ${Math.round(ratio*100)}%.`);
                            return; 
                        }
                    }

                    const area = calculateArea(coordinates);
                    const perimeter = calculatePerimeter(coordinates);

                    let yearBuilt = null;
                    if (element.tags['start_date']) {
                        yearBuilt = extractYearFromDate(element.tags['start_date']);
                    }
                    if (!yearBuilt && element.tags['construction:date']) {
                        yearBuilt = extractYearFromDate(element.tags['construction:date']);
                    }

                    // Return the specific object structure the app expects
                    buildings.push({
                        seqNum: sequenceNumber++,
                        bldgNum: '',
                        name: element.tags.name || 'Unnamed',
                        description: element.tags.description || element.tags['addr:street'] || '-',
                        area: area,
                        perimeter: perimeter,
                        height: element.tags.height ? parseFloat(element.tags.height) : null,
                        floorLevels: element.tags['building:levels'] ? parseInt(element.tags['building:levels']) : null,
                        yearBuilt: yearBuilt,
                        osmId: element.id,
                        osmType: element.type,
                        coordinates: coordinates, // [lon, lat] format
                        tags: element.tags
                    });
                }
            });
            
            return buildings;
        }



        /**
         * Orchestrates the data extraction process: builds the query, executes it,
         * processes the results, and updates the map and table.
         * @returns {Promise<void>}
         */
        async function executeDataExtraction() {
           console.log('executeDataExtraction called. searchAreaDefined:', searchAreaDefined, 'currentBoundaryLayer:', currentBoundaryLayer);

            if (searchAreaDefined === 'None') {
                showStatus('Please define a search area first (GeoJSON, Address, or Bounding Box).', 'error');
                return;
            }
            
            if (!currentBoundaryLayer) {
                showStatus('Boundary layer not found. Please redefine search area.', 'error');
                console.error('currentBoundaryLayer is null despite searchAreaDefined being:', searchAreaDefined);
                return;
            }
            showStatus('Building Overpass query...', 'success', 2000);
            
            const query = buildOverpassQuery();
            if (!query) {
                return;
            }
            
            console.log('Overpass Query:', query);
            showStatus('Querying OpenStreetMap data...', 'success', 5000);
            
            try {
                const data = await executeOverpassQuery(query);
                
                if (!data.elements || data.elements.length === 0) {
                    showStatus('No buildings found in the specified area BBOX.', 'error', 4000);
                    populateDataTable([]);
                    return;
                }
                
                showStatus(`Retrieved ${data.elements.length} OSM elements. Applying ${BOUNDARY_TOLERANCE_RATIO*100}% area-ratio filter... (Check console for detailed logs)`, 'success', 3000);
                
                const buildings = processOverpassData(data);
                
                if (buildings.length === 0) {
                    showStatus('No valid building footprints found within the defined tolerance.', 'error', 4000);
                    populateDataTable([]);
                    return;
                }
                
                console.log('Processed Buildings:', buildings);
                showStatus(`Successfully processed ${buildings.length} buildings!`, 'success', 3000);
                
                window.currentBuildingsData = buildings;
                
                populateDataTable(buildings);
                displayBuildingsOnMap(buildings);
                
                if (!dataPanel.classList.contains('expanded')) {
                    toggleDataPanel();
                }
                
            } catch (error) {
                showStatus(`Data extraction failed: ${error.message}`, 'error', 6000);
                console.error('Overpass query error:', error);
            }
        }

        /**
         * Populates the data table with building information and updates table headers
         * based on the current unit system. Also attaches event listeners for editing.
         * @param {Array<Object>} buildings - Array of structured building data objects.
         */
        function populateDataTable(buildings) {
            const tbody = document.querySelector('#data-table tbody');
            const th_area = document.querySelector('#data-table thead th:nth-child(4)'); // Updated index
            const th_perimeter = document.querySelector('#data-table thead th:nth-child(5)');
            const th_height = document.querySelector('#data-table thead th:nth-child(6)');

            // Update headers based on current unit system
            if (currentUnitSystem === 'metric') {
                th_area.textContent = 'Area (sqm)';
                th_perimeter.textContent = 'Perimeter (m)';
                th_height.textContent = 'Height (m)';
            } else {
                th_area.textContent = 'Area (sqft)';
                th_perimeter.textContent = 'Perimeter (ft)';
                th_height.textContent = 'Height (ft)';
            }

            tbody.innerHTML = '';
            
            if (buildings.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 16px; border-bottom: none;">No buildings found based on current criteria.</td></tr>';
                const totalAreaFormatted = formatMeasurement(0, 'area');
                document.getElementById('property-name-address').textContent = `Results: 0 buildings | Total Area: 0 ${totalAreaFormatted.unit}`;
                return;
            }

            buildings.forEach((building, index) => {
                const row = document.createElement('tr');
                row.style.cursor = 'pointer';
                row.dataset.buildingIndex = index;

                const area = formatMeasurement(building.area, 'area');
                const perimeter = formatMeasurement(building.perimeter, 'length');
                const height = formatMeasurement(building.height, 'height');
                
                row.innerHTML = `
                    <td>${building.seqNum}</td>
                    <td contenteditable="true" class="editable-cell" data-field="bldgNum" style="background-color: #FFF9E6;">${building.bldgNum || ''}</td>
                    <td contenteditable="true" class="editable-cell" data-field="name" style="background-color: #FFF9E6;">${building.name}</td>
                    <td>${area.value}</td>
                    <td>${perimeter.value}</td>
                    <td>${height.value}</td>
                    <td>${building.floorLevels || '-'}</td>
                    <td>${building.yearBuilt || '-'}</td>
                    <td>${building.osmId}</td>
                `;
                
                // Add click handler for row highlighting (but prevent for editable cells)
                row.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('editable-cell')) {
                        highlightBuildingOnMap(index);
                    }
                });
                
                // Handle editable cell updates
                row.querySelectorAll('.editable-cell').forEach(cell => {
                    cell.addEventListener('blur', (e) => {
                        const field = e.target.dataset.field;
                        const newValue = e.target.textContent.trim();
                        window.currentBuildingsData[index][field] = newValue;
                        
                        // If label mode is enabled, update the map markers
                        if (labelModeEnabled) {
                            displayBuildingsOnMap(window.currentBuildingsData);
                        }
                        
                        showStatus(`Updated ${field} for building ${building.seqNum}`, 'success', 1500);
                    });
                    
                    // Prevent Enter key from adding new lines
                    cell.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.target.blur();
                        }
                    });
                });
                
                tbody.appendChild(row);
            });
            
            const totalAreaMetric = buildings.reduce((sum, b) => sum + b.area, 0);
            const totalAreaFormatted = formatMeasurement(totalAreaMetric, 'area');
            document.getElementById('property-name-address').textContent = 
                `Results: ${buildings.length} buildings | Total Area: ${totalAreaFormatted.value} ${totalAreaFormatted.unit}`;
        }

        /**
         * Displays building footprints and sequence number/label markers on the map.
         * @param {Array<Object>} buildings - Array of structured building data objects.
         */
        function displayBuildingsOnMap(buildings) {
            if (window.buildingsLayerGroup) {
                map.removeLayer(window.buildingsLayerGroup);
            }
            
            window.buildingsLayerGroup = L.layerGroup();
            
            buildings.forEach((building, index) => {
                // Leaflet expects [lat, lon], coordinates array is [lon, lat]
                const latLngs = building.coordinates.map(coord => [coord[1], coord[0]]);
                
                // --- 1. Building Footprint Polygon ---
                const polygon = L.polygon(latLngs, {
                    color: '#FF6B35',
                    weight: 2,
                    fillColor: '#FF6B35',
                    fillOpacity: 0.3
                });
                
                const area = formatMeasurement(building.area, 'area');
                const perimeter = formatMeasurement(building.perimeter, 'length');
                const height = formatMeasurement(building.height, 'height');
                
                const popupContent = `
                    <strong>${building.name}</strong><br>
                    ${building.bldgNum ? `Bldg Num: ${building.bldgNum}<br>` : ''}
                    Area: ${area.value} ${area.unit}<br>
                    Perimeter: ${perimeter.value} ${perimeter.unit}<br>
                    Height: ${height.value} ${height.unit}<br>
                    Levels: ${building.floorLevels || 'N/A'}<br>
                    Year Built: ${building.yearBuilt || 'N/A'}<br>
                    OSM ID: ${building.osmId}
                `;

                polygon.bindPopup(popupContent);
                polygon.buildingIndex = index;
                window.buildingsLayerGroup.addLayer(polygon);
                
                // --- 2. Sequence Number or Label Marker ---
                try {
                    const centerPoint = turf.center(turf.polygon([building.coordinates]));
                    const centerCoords = centerPoint.geometry.coordinates;
                    
                    let markerHTML, iconSize, iconAnchor;
                    
                    if (labelModeEnabled && (building.bldgNum || building.name)) {
                        // Label Mode: Show Bldg Num + Name
                        const labelText = building.bldgNum 
                            ? `${building.bldgNum} â€“ ${building.name}`
                            : building.name;
                        
                        markerHTML = `<div style="
                            background-color: var(--color-primary);
                            color: var(--color-on-primary);
                            padding: 4px 8px;
                            border-radius: 12px;
                            font-size: 0.75rem;
                            font-weight: 500;
                            white-space: nowrap;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                            border: 2px solid white;
                        ">${labelText}</div>`;
                        
                        iconSize = null; // Auto-size based on content
                        iconAnchor = [0, 0]; // Adjust as needed
                        
                    } else {
                        // Standard Mode: Show Seq.Num only
                        markerHTML = `<span>${building.seqNum}</span>`;
                        iconSize = [24, 24];
                        iconAnchor = [12, 12];
                    }
                    
                    const markerIcon = L.divIcon({
                        className: labelModeEnabled ? 'label-marker' : 'seq-marker',
                        html: markerHTML,
                        iconSize: iconSize,
                        iconAnchor: iconAnchor
                    });
                    
                    const marker = L.marker([centerCoords[1], centerCoords[0]], { 
                        icon: markerIcon,
                        title: `Building ${building.seqNum}: ${building.name}`
                    });

                    marker.on('click', () => {
                        highlightBuildingOnMap(index);
                        if (!dataPanel.classList.contains('expanded')) {
                            toggleDataPanel();
                        }
                    });
                    
                    marker.buildingIndex = index;
                    marker.bindPopup(popupContent);
                    window.buildingsLayerGroup.addLayer(marker);

                } catch (e) {
                    console.warn(`Could not calculate centroid for building ID ${building.osmId}:`, e);
                }
            });
            
            window.buildingsLayerGroup.addTo(map);
        }

        /**
         * Highlights a specific building polygon on the map and zooms to its bounds.
         * @param {number} buildingIndex - The index of the building in the currentBuildingsData array.
         */
        function highlightBuildingOnMap(buildingIndex) {
            // Find and zoom to the selected building
            window.buildingsLayerGroup.eachLayer(layer => {
                if (layer.buildingIndex === buildingIndex) {
                    // Only fit bounds/style the polygon, but open popup for both marker/polygon
                    if (layer instanceof L.Polygon) {
                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });
                        
                        // Highlight style
                        layer.setStyle({ 
                            color: '#1E4D9C',
                            weight: 4,
                            fillOpacity: 0.5
                        });

                        // Reset style
                        setTimeout(() => {
                            layer.setStyle({
                                color: '#FF6B35',
                                weight: 2,
                                fillOpacity: 0.3
                            });
                        }, 2000);
                    }
                    layer.openPopup();
                }
            });
        }

        // --- CSV Export Implementation ---

        exportCsvBtn.addEventListener('click', () => {
            if (!window.currentBuildingsData || window.currentBuildingsData.length === 0) {
                showStatus('No data to export.', 'error');
                return;
            }

            const headers = [
                "Seq.Num",
                "Bldg Num",
                "Name",
                `Area (${currentUnitSystem === 'metric' ? 'sqm' : 'sqft'})`,
                `Perimeter (${currentUnitSystem === 'metric' ? 'm' : 'ft'})`,
                `Height (${currentUnitSystem === 'metric' ? 'm' : 'ft'})`,
                "Floor Levels",
                "YrBlt",  // NEW COLUMN
                "OSM ID",
                "Centroid Latitude",
                "Centroid Longitude",
                "Footprint Coordinates",
                "Tags"
            ];

            let csvContent = headers.join(",") + "\n";

            window.currentBuildingsData.forEach(item => {
                const area = formatMeasurement(item.area, 'area');
                const perimeter = formatMeasurement(item.perimeter, 'length');
                const height = formatMeasurement(item.height, 'height');

                let lat = '';
                let lon = '';
                try {
                    const center = turf.center(turf.polygon([item.coordinates]));
                    lon = center.geometry.coordinates[0].toFixed(6);
                    lat = center.geometry.coordinates[1].toFixed(6);
                } catch (e) {
                    console.error('Centroid calculation failed for building:', item.osmId, e);
                }

                // Format footprint coordinates as JSON string
                const footprintCoords = JSON.stringify(item.coordinates);

                const cleanValue = (v) => v.toString().replace(/,/g, '');

                const row = [
                    item.seqNum,
                    `"${(item.bldgNum || '').replace(/"/g, '""')}"`,
                    `"${item.name.replace(/"/g, '""')}"`,
                    cleanValue(area.value), 
                    cleanValue(perimeter.value),
                    cleanValue(height.value),
                    item.floorLevels || '',
                    item.yearBuilt || '',  // NEW FIELD
                    item.osmId,
                    lat,
                    lon,
                    `"${footprintCoords.replace(/"/g, '""')}"`,
                    `"${JSON.stringify(item.tags).replace(/"/g, '""')}"`
                ];
                csvContent += row.join(",") + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `property_data_csv_export_${new Date().toISOString().slice(0, 10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showStatus('CSV data exported successfully!', 'success', 3000);
            }
        });

        // --- GeoJSON Export Implementation ---
        
        exportGeoJsonBtn.addEventListener('click', exportGeoJson);

        /**
         * Exports the current buildings data into a GeoJSON FeatureCollection,
         * including both Polygon (footprint) and Point (centroid) features.
         */
        function exportGeoJson() {
            if (!window.currentBuildingsData || window.currentBuildingsData.length === 0) {
                showStatus('No data to export.', 'error');
                return;
            }

            const features = [];
            
            window.currentBuildingsData.forEach(item => {
                const commonProperties = {
                    'seq_num': item.seqNum,
                    'bldg_num': item.bldgNum || '',
                    'name': item.name,
                    'osm_id': item.osmId,
                    'area_sqm': item.area,
                    'perimeter_m': item.perimeter,
                    'height_m': item.height,
                    'floor_levels': item.floorLevels,
                    'year_built': item.yearBuilt,  // NEW PROPERTY
                    'unit_system_exported': 'metric',
                    'osm_tags': item.tags
                };

                // 1. Building Footprint (Polygon Feature)
                try {
                    const polygonFeature = turf.polygon([item.coordinates], {
                        ...commonProperties,
                        'osm_element_type': item.osmType,
                        'data_entity_type': 'building_footprint',
                        'description': 'Building footprint polygon (OSM Way geometry)'
                    });
                    features.push(polygonFeature);
                } catch (e) {
                    console.error('Failed to create Polygon feature for ID:', item.osmId, e);
                }
                
                // 2. Data Pushpin (Point Feature - Centroid)
                try {
                    const centerPoint = turf.center(turf.polygon([item.coordinates]));
                    
                    const pointFeature = turf.point(centerPoint.geometry.coordinates, {
                        ...commonProperties,
                        'osm_element_type': item.osmType,
                        'data_entity_type': 'data_pushpin_centroid',
                        'label': item.bldgNum 
                            ? `${item.bldgNum} â€“ ${item.name}` 
                            : `Seq ${item.seqNum}: ${item.name}`
                    });
                    features.push(pointFeature);
                } catch (e) {
                     console.warn('Failed to create Point feature (centroid) for ID:', item.osmId, e);
                }
            });

            const featureCollection = {
                type: 'FeatureCollection',
                metadata: {
                    name: `Property Data Export - ${new Date().toISOString().slice(0, 10)}`,
                    generated_by: 'Property Data Validation and Benchmarking App',
                    feature_count: features.length
                },
                features: features
            };

            const jsonString = JSON.stringify(featureCollection, null, 2);
            const blob = new Blob([jsonString], { type: 'application/geojson;charset=utf-8;' });
            const link = document.createElement("a");
            
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `property_data_geojson_export_${new Date().toISOString().slice(0, 10)}.geojson`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showStatus('GeoJSON data exported successfully!', 'success', 3000);
            }
        }


        // --- Core Search Execution Logic ---
        // Track the last geocoded address to detect changes
        let lastGeocodedAddress = '';

        document.getElementById('execute-search').addEventListener('click', () => {
            const currentAddress = addressInput.value.trim();
            const hasAddress = currentAddress !== '';
            const addressChanged = currentAddress !== lastGeocodedAddress;
            
            // Hide the action prompt when user takes action
            hideActionPrompt();
            
            if (hasAddress && (searchAreaDefined === 'None' || (searchAreaDefined === 'Chips' && addressChanged))) {
                geocodeAddress(currentAddress);
            } 
            else if (searchAreaDefined !== 'None' && !addressChanged) {
                executeDataExtraction();
            } 
            else if (!hasAddress && searchAreaDefined !== 'None') {
                executeDataExtraction();
            }
            else {
                showStatus('Please enter an address or define a map boundary.', 'error');
            }
        });
        
        addressInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (addressInput.value.trim() !== '' && searchAreaDefined === 'None') {
                    geocodeAddress(addressInput.value);
                } else if (searchAreaDefined !== 'None') {
                    executeDataExtraction();
                } else {
                    showStatus('Please enter an address or define a map boundary.', 'error');
                }
                handleGeocodeSuccess();
            }
        });

        // --- Placeholder Functionality (Table Sorting) ---

        document.querySelector('#data-table thead').addEventListener('click', (e) => {
            if (e.target.tagName === 'TH') {
                showStatus(`Sorting triggered for column: ${e.target.textContent.trim()} (Phase 4 - To be implemented)`, 'success', 2000);
            }
        });

        console.log("Application initialized. GeoJSON Export feature fixed.");

        // --- PRODUCT TOUR INITIALIZATION  ---

    const helpButton = document.getElementById('help-button');

    // Create the Driver instance with options
    const tour = new window.driver.js.driver({
        overlayOpacity: 0.25,
        padding: 12,
        allowClose: true,
        showButtons: ['next', 'previous', 'close'],
        showProgress: true,
        onDestroyed: () => {
            toggleSidebar(false); // Ensure sidebar is closed after tour
            if (helpButton) {
                helpButton.disabled = false;
                helpButton.style.opacity = '1';
            }
            toggleSidebar(false); // Ensure sidebar is closed after tour
            console.log('Tour ended');
        },

        steps: [
        { element: '#help-button', popover: { title: 'Need Help?', description: 'Click this button anytime to start the product navigation tour.', side: "right", align: 'start' }},
        { popover: { title: 'Welcome to the Property Data Tool!', description: 'This tour will guide you through the main features of the application. Let\'s get started!', side: "bottom", align: 'start' }},
        { element: '#sidebar-toggle', popover: { title: 'Navigation Menu', description: 'Click here now to see how to access spatial tools for drawing boundaries or clearing selections. Click the arrow to close.', side: "right", align: 'start', onNextClick: () => { toggleSidebar(true); tour.moveNext(); } }},
        { element: '#draw-bbox-tool', popover: { title: 'Draw Area Tool', description: 'After searching for an address, clear the map boundary and define your custom search area by using this button to open drawing tools. Select area by Box or Polygon on the map.', side: "right", align: 'start' }},
        { element: '#clear-map-tool', popover: { title: 'Clear Map Boundary', description: 'Use this button to clear all boundaries that have been set. All boundaries must be reset before another search.', side: "right", align: 'start', onNextClick: () => { toggleSidebar(false); tour.moveNext(); } }},
        { element: '.search-bar', popover: { title: 'Search Bar', description: 'Use Country/Region filter to define your area of search and enter an Address. Input the street number, name and City and press Enter', side: "bottom", align: 'start' }},
        { element: '#execute-search', popover: { title: 'Execute Search', description: 'Once the address is found, click here or press enter again to retrieve all building data at that location. Alternatively, clear the boundary box from the navigation menu and use draw feature to select buildings.', side: "left", align: 'start' }},
        { element: '#data-panel', popover: { title: 'Results Panel', description: 'All retrieved property data will be displayed in this table. Click anywhere in the header or the arrow to expand it. You can add your own building numbers and change the building name before exporting data.', side: "top", align: 'start' }},
        { element: '#export-csv', popover: { title: 'Export CSV', description: 'Click here to download the results as a CSV file for spreadsheet viewing or loading back into app at a later date for building location references.', side: "top", align: 'start' }},
        { element: '#export-geojson', popover: { title: 'Export GeoJSON', description: 'Use this button to export building footprints as GeoJSON for use in Google Earth Pro or GIS applications.', side: "top", align: 'start' }},
        { popover: { title: 'Tour Complete!', description: 'You\'ve mastered the core workflow: Define Area and Extract Data. Happy Validating!' } }
        ]

    });

    // Hook up the help button
    if (helpButton) {
        helpButton.addEventListener('click', () => {
        console.log('Starting tour...');
        helpButton.disabled = true;
        helpButton.style.opacity = '0.6';
        tour.drive(); // .start() âœ… correct method to begin the tour in v1.3.1
        });
    }

    </script>

    <!-- Separate Tour Initialization Script (runs after main script) -->
    <script>
        console.log('ðŸŽ¯ Tour initialization script loaded');
        
        // Wait for DOM and driver.js to be fully ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('âœ“ DOM Content Loaded');
            
            // Check driver.js availability
            setTimeout(() => {
                if (typeof driver !== 'undefined') {
                    console.log('âœ“ Driver.js is available as:', typeof driver);
                    console.log('âœ“ Driver.js API ready for product tour');
                } else {
                    console.warn('âš ï¸ Driver.js not available, using built-in fallback tour');
                }
            }, 100);
        });

        // Enhanced window load event for final verification
        window.addEventListener('load', () => {
            console.log('âœ“ Window load complete - tour should be fully initialized');
            if (typeof appTour !== 'undefined' && appTour) {
                console.log('âœ“ appTour object exists:', appTour);
            }
        });
    </script>
</body>
</html>